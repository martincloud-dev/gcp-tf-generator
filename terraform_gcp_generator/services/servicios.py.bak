"""
Definiciones de servicios de GCP disponibles para generación.
"""

import os
from pathlib import Path

# Obtener la ruta base del paquete para acceder a las plantillas
BASE_DIR = Path(__file__).parent.parent

# Lista de servicios GCP disponibles
SERVICIOS_DISPONIBLES = [
    "compute-engine",
    "cloud-storage",
    "cloud-sql",
    "cloud-run",
    "bigquery",
    "kubernetes-engine",
    "cloud-functions",
    "load-balancer",
    "vpc",
    "iam",
    "firewall",
    "dns",
    "cloud-armor",
    "cdn",
    "cloud-nat",
    "ssl-certificate"
]

# Información detallada de cada servicio
SERVICIOS_INFO = {
    "compute-engine": {
        "descripcion": "Máquinas virtuales escalables en la infraestructura de Google",
        "archivo": "compute_engine.tf.tpl",
        "abreviatura": "ce"
    },
    "cloud-storage": {
        "descripcion": "Servicio de almacenamiento de objetos",
        "archivo": "cloud_storage.tf.tpl",
        "abreviatura": "cs"
    },
    "cloud-sql": {
        "descripcion": "Servicio de base de datos relacional totalmente gestionado",
        "archivo": "cloud_sql.tf.tpl",
        "abreviatura": "csql"
    },
    "cloud-run": {
        "descripcion": "Plataforma de computación serverless para contenedores",
        "archivo": "cloud_run.tf.tpl",
        "abreviatura": "cr"
    },
    "bigquery": {
        "descripcion": "Almacén de datos empresarial y servicio de análisis",
        "archivo": "bigquery.tf.tpl",
        "abreviatura": "bq"
    },
    "kubernetes-engine": {
        "descripcion": "Servicio Kubernetes gestionado y optimizado",
        "archivo": "kubernetes_engine.tf.tpl",
        "abreviatura": "gke"
    },
    "cloud-functions": {
        "descripcion": "Plataforma de ejecución de funciones serverless",
        "archivo": "cloud_functions.tf.tpl",
        "abreviatura": "cf"
    },
    "load-balancer": {
        "descripcion": "Balanceadores de carga HTTP(S), TCP/SSL y de red",
        "archivo": "load_balancer.tf.tpl",
        "abreviatura": "lb"
    },
    "vpc": {
        "descripcion": "Redes privadas virtuales definidas por software",
        "archivo": "vpc.tf.tpl",
        "abreviatura": "vpc"
    },
    "iam": {
        "descripcion": "Gestión de identidades y accesos",
        "archivo": "iam.tf.tpl",
        "abreviatura": "iam"
    },
    "firewall": {
        "descripcion": "Reglas de firewall para controlar el tráfico de red",
        "archivo": "firewall.tf.tpl",
        "abreviatura": "fw"
    },
    "dns": {
        "descripcion": "Servicio de resolución de nombres de dominio",
        "archivo": "dns.tf.tpl",
        "abreviatura": "dns"
    },
    "cloud-armor": {
        "descripcion": "Protección contra ataques DDoS y amenazas web",
        "archivo": "cloud_armor.tf.tpl",
        "abreviatura": "armor"
    },
    "cdn": {
        "descripcion": "Red de distribución de contenido",
        "archivo": "cdn.tf.tpl",
        "abreviatura": "cdn"
    },
    "cloud-nat": {
        "descripcion": "Traducción de direcciones de red para GCP",
        "archivo": "cloud_nat.tf.tpl",
        "abreviatura": "nat"
    },
    "ssl-certificate": {
        "descripcion": "Certificados SSL/TLS para balanceadores de carga",
        "archivo": "ssl_certificate.tf.tpl",
        "abreviatura": "ssl"
    }
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "armor_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
"""
Definiciones de servicios de GCP disponibles para generación.
"""

import os
from pathlib import Path

# Obtener la ruta base del paquete para acceder a las plantillas
BASE_DIR = Path(__file__).parent.parent

# Lista de servicios GCP disponibles
SERVICIOS_DISPONIBLES = [
    "compute-engine",
    "cloud-storage",
    "cloud-sql",
    "cloud-run",
    "bigquery",
    "kubernetes-engine",
    "cloud-functions",
    "load-balancer",
    "vpc",
    "iam",
    "firewall",
    "dns",
    "cloud-armor",
    "cdn",
    "cloud-nat",
    "ssl-certificate"
]

# Información detallada de cada servicio
SERVICIOS_INFO = {
    "compute-engine": {
        "descripcion": "Máquinas virtuales escalables en la infraestructura de Google",
        "archivo": "compute_engine.tf.tpl",
        "abreviatura": "ce"
    },
    "cloud-storage": {
        "descripcion": "Servicio de almacenamiento de objetos",
        "archivo": "cloud_storage.tf.tpl",
        "abreviatura": "cs"
    },
    "cloud-sql": {
        "descripcion": "Servicio de base de datos relacional totalmente gestionado",
        "archivo": "cloud_sql.tf.tpl",
        "abreviatura": "csql"
    },
    "cloud-run": {
        "descripcion": "Plataforma de computación serverless para contenedores",
        "archivo": "cloud_run.tf.tpl",
        "abreviatura": "cr"
    },
    "bigquery": {
        "descripcion": "Almacén de datos empresarial y servicio de análisis",
        "archivo": "bigquery.tf.tpl",
        "abreviatura": "bq"
    },
    "kubernetes-engine": {
        "descripcion": "Servicio Kubernetes gestionado y optimizado",
        "archivo": "kubernetes_engine.tf.tpl",
        "abreviatura": "gke"
    },
    "cloud-functions": {
        "descripcion": "Plataforma de ejecución de funciones serverless",
        "archivo": "cloud_functions.tf.tpl",
        "abreviatura": "cf"
    },
    "load-balancer": {
        "descripcion": "Balanceadores de carga HTTP(S), TCP/SSL y de red",
        "archivo": "load_balancer.tf.tpl",
        "abreviatura": "lb"
    },
    "vpc": {
        "descripcion": "Redes privadas virtuales definidas por software",
        "archivo": "vpc.tf.tpl",
        "abreviatura": "vpc"
    },
    "iam": {
        "descripcion": "Gestión de identidades y accesos",
        "archivo": "iam.tf.tpl",
        "abreviatura": "iam"
    },
    "firewall": {
        "descripcion": "Reglas de firewall para controlar el tráfico de red",
        "archivo": "firewall.tf.tpl",
        "abreviatura": "fw"
    },
    "dns": {
        "descripcion": "Servicio de resolución de nombres de dominio",
        "archivo": "dns.tf.tpl",
        "abreviatura": "dns"
    },
    "cloud-armor": {
        "descripcion": "Protección contra ataques DDoS y amenazas web",
        "archivo": "cloud_armor.tf.tpl",
        "abreviatura": "armor"
    },
    "cdn": {
        "descripcion": "Red de distribución de contenido",
        "archivo": "cdn.tf.tpl",
        "abreviatura": "cdn"
    },
    "cloud-nat": {
        "descripcion": "Traducción de direcciones de red para GCP",
        "archivo": "cloud_nat.tf.tpl",
        "abreviatura": "nat"
    },
    "ssl-certificate": {
        "descripcion": "Certificados SSL/TLS para balanceadores de carga",
        "archivo": "ssl_certificate.tf.tpl",
        "abreviatura": "ssl"
    }
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "armor_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
  name     = "app_database"
  instance = google_sql_database_instance.instance.name
  charset  = "utf8mb4"
  collation = "utf8mb4_general_ci"
}

# Usuario
resource "google_sql_user" "user" {
  name     = "app_user"
  instance = google_sql_database_instance.instance.name
  host     = "%"
  password = "changeme"  # Cambiar por variable o secreto
}

output "database_instance_connection_name" {
  value = google_sql_database_instance.instance.connection_name
}

output "database_instance_ip" {
  value = google_sql_database_instance.instance.public_ip_address
}
""",

        "cloud-run": """# Servicio de Cloud Run
resource "google_cloud_run_service" "service" {
  name     = "${var.project_id}-service"
  location = var.region

  template {
    spec {
      containers {
        image = "gcr.io/cloudrun/hello"
        
        resources {
          limits = {
            cpu    = "1000m"
            memory = "512Mi"
          }
        }
        
        env {
          name  = "ENVIRONMENT"
          value = "production"
        }
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }
}

# IAM para Cloud Run (público)
resource "google_cloud_run_service_iam_member" "public_access" {
  service  = google_cloud_run_service.service.name
  location = google_cloud_run_service.service.location
  role     = "roles/run.invoker"
  member   = "allUsers"
}

output "cloud_run_url" {
  value = google_cloud_run_service.service.status[0].url
}
""",

        "bigquery": """# Conjunto de datos de BigQuery
resource "google_bigquery_dataset" "dataset" {
  dataset_id                  = "example_dataset"
  friendly_name               = "Example Dataset"
  description                 = "Este es un conjunto de datos de ejemplo"
  location                    = var.region
  default_table_expiration_ms = 3600000 * 24 * 7  # 1 semana

  access {
    role          = "OWNER"
    special_group = "projectOwners"
  }

  access {
    role          = "READER"
    special_group = "projectReaders"
  }
}

# Tabla de BigQuery
resource "google_bigquery_table" "table" {
  dataset_id = google_bigquery_dataset.dataset.dataset_id
  table_id   = "example_table"
  
  time_partitioning {
    type  = "DAY"
    field = "ts"
  }
  
  schema = <<EOF
[
  {
    "name": "ts",
    "type": "TIMESTAMP",
    "mode": "REQUIRED",
    "description": "Timestamp del evento"
  },
  {
    "name": "user_id",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "ID del usuario"
  },
  {
    "name": "event",
    "type": "STRING",
    "mode": "NULLABLE",
    "description": "Tipo de evento"
  },
  {
    "name": "data",
    "type": "JSON",
    "mode": "NULLABLE",
    "description": "Datos del evento"
  }
]
EOF
}

output "dataset_id" {
  value = google_bigquery_dataset.dataset.dataset_id
}

output "table_id" {
  value = "${google_bigquery_dataset.dataset.dataset_id}.${google_bigquery_table.table.table_id}"
}
""",

        "kubernetes-engine": """# Cluster de GKE
resource "google_container_cluster" "primary" {
  name     = "${var.project_id}-gke-cluster"
  location = var.zone
  
  # Eliminar el node pool por defecto
  remove_default_node_pool = true
  initial_node_count       = 1
  
  # Networking
  network    = "default"
  subnetwork = "default"
  
  # Configuración de cluster
  cluster_autoscaling {
    enabled = false
  }
  
  # Habilitar Istio (opcional)
  # addons_config {
  #   istio_config {
  #     disabled = false
  #     auth     = "AUTH_MUTUAL_TLS"
  #   }
  # }
}

# Node pool separado
resource "google_container_node_pool" "primary_nodes" {
  name       = "${var.project_id}-node-pool"
  location   = var.zone
  cluster    = google_container_cluster.primary.name
  node_count = 2

  node_config {
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
    ]

    labels = {
      env = var.environment
    }

    # Filtros de Taints (opcional)
    # taint {
    #   key    = "dedicated"
    #   value  = "gpu"
    #   effect = "NO_SCHEDULE"
    # }

    machine_type = "e2-medium"
    tags         = ["gke-node", "${var.project_id}-gke"]
    disk_size_gb = 30
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Autoscaling (opcional)
  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
  
  # Política de actualización
  management {
    auto_repair  = true
    auto_upgrade = true
  }
}

output "kubernetes_cluster_name" {
  value = google_container_cluster.primary.name
}

output "kubernetes_cluster_endpoint" {
  value = google_container_cluster.primary.endpoint
}
""",

        "cloud-functions": """# Bucket para el código fuente
resource "google_storage_bucket" "function_bucket" {
  name          = "${var.project_id}-function-bucket"
  location      = var.region
  force_destroy = true
}

# Archivo ZIP para la función
resource "google_storage_bucket_object" "function_zip" {
  name   = "function-source.zip"
  bucket = google_storage_bucket.function_bucket.name
  source = "./functions/function-source.zip"  # Debe existir localmente
  
  # Si no existe el archivo localmente, puedes usar esto para crear un ZIP vacío:
  # content = "# Placeholder para función"
  # content_type = "application/zip"
}

# Función de Cloud Functions
resource "google_cloudfunctions_function" "function" {
  name        = "${var.project_id}-function"
  description = "Mi función ejemplo"
  runtime     = "python310"
  
  available_memory_mb   = 128
  source_archive_bucket = google_storage_bucket.function_bucket.name
  source_archive_object = google_storage_bucket_object.function_zip.name
  trigger_http          = true
  entry_point           = "hello_world"  # Nombre de la función en el código
  
  environment_variables = {
    PROJECT_ID = var.project_id
    ENV        = var.environment
  }
  
  # Timeouts
  timeout     = 60
  max_instances = 10
}

# IAM para permitir invocación pública de la función
resource "google_cloudfunctions_function_iam_member" "invoker" {
  project        = var.project_id
  region         = var.region
  cloud_function = google_cloudfunctions_function.function.name
  
  role   = "roles/cloudfunctions.invoker"
  member = "allUsers"
}

output "function_url" {
  value = google_cloudfunctions_function.function.https_trigger_url
}
""",

        "load-balancer": """####################################
         LOAD BALANCER IP
####################################
resource "google_compute_global_address" "lb_ip" {
  name = "${var.project_id}-lb-ip"
}

####################################
         SSL CERTIFICATE
####################################
resource "google_compute_managed_ssl_certificate" "default" {
  name = "${var.project_id}-cert"

  managed {
    domains = ["example.${var.project_id}.com"]
  }
}

####################################
         HEALTH CHECK
####################################
resource "google_compute_health_check" "default" {
  name               = "${var.project_id}-http-health-check"
  timeout_sec        = 5
  check_interval_sec = 10

  http_health_check {
    port = 80
    request_path = "/"
  }
}

####################################
         BACKEND SERVICE
####################################
resource "google_compute_backend_service" "default" {
  name                  = "${var.project_id}-backend-service"
  protocol              = "HTTP"
  port_name             = "http"
  timeout_sec           = 30
  health_checks         = [google_compute_health_check.default.id]
  
  # Aquí conectarías con tu grupo de instancias
  # backend {
  #   group = google_compute_instance_group_manager.default.instance_group
  # }
}

####################################
         URL MAP
####################################
resource "google_compute_url_map" "default" {
  name            = "${var.project_id}-url-map"
  default_service = google_compute_backend_service.default.id
}

####################################
         HTTP REDIRECT
####################################
resource "google_compute_url_map" "https_redirect" {
  name = "${var.project_id}-https-redirect"

  default_url_redirect {
    https_redirect         = true
    redirect_response_code = "MOVED_PERMANENTLY_DEFAULT"
    strip_query            = false
  }
}

####################################
         HTTP PROXY
####################################
resource "google_compute_target_http_proxy" "default" {
  name    = "${var.project_id}-http-proxy"
  url_map = google_compute_url_map.https_redirect.id
}

####################################
         HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "default" {
  name             = "${var.project_id}-https-proxy"
  url_map          = google_compute_url_map.default.id
  ssl_certificates = [google_compute_managed_ssl_certificate.default.id]
}

####################################
         HTTP FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "http" {
  name                  = "${var.project_id}-http-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "80"
  target                = google_compute_target_http_proxy.default.id
}

####################################
         HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "https" {
  name                  = "${var.project_id}-https-forwarding-rule"
  ip_address            = google_compute_global_address.lb_ip.address
  port_range            = "443"
  target                = google_compute_target_https_proxy.default.id
}

output "load_balancer_ip" {
  value = google_compute_global_address.lb_ip.address
}
""",

        "vpc": """####################################
         VPC NETWORK
####################################
# Red VPC
resource "google_compute_network" "vpc_network" {
  name                    = "${var.project_id}-vpc"
  auto_create_subnetworks = false
  description             = "Red VPC principal para ${var.project_id}"
}

####################################
         SUBNET CONFIGURATION
####################################
# Subred en la región principal
resource "google_compute_subnetwork" "main_subnet" {
  name          = "${var.project_id}-subnet-${var.region}"
  ip_cidr_range = "10.0.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Habilitar Private Google Access
  private_ip_google_access = true
  
  # Opciones de logs de flujo (opcional)
  log_config {
    aggregation_interval = "INTERVAL_5_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}

####################################
         SUBNET SECONDARY RANGES
####################################
# Subred con rangos secundarios para Kubernetes/GKE
resource "google_compute_subnetwork" "gke_subnet" {
  name          = "${var.project_id}-gke-subnet-${var.region}"
  ip_cidr_range = "10.1.0.0/20"
  region        = var.region
  network       = google_compute_network.vpc_network.id
  
  # Rangos secundarios para Pods y Servicios en GKE
  secondary_ip_range {
    range_name    = "pod-ranges"
    ip_cidr_range = "10.2.0.0/16"
  }
  
  secondary_ip_range {
    range_name    = "services-ranges" 
    ip_cidr_range = "10.3.0.0/20"
  }
}

####################################
         ROUTES
####################################
# Route para tráfico de Internet
resource "google_compute_route" "internet_route" {
  name             = "${var.project_id}-internet-route"
  network          = google_compute_network.vpc_network.id
  dest_range       = "0.0.0.0/0"
  priority         = 1000
  next_hop_gateway = "default-internet-gateway"
}

####################################
         VPC PEERING
####################################
# VPC Network Peering (opcional)
# resource "google_compute_network_peering" "peering" {
#   name         = "${var.project_id}-peering"
#   network      = google_compute_network.vpc_network.id
#   peer_network = "projects/otro-proyecto/global/networks/otra-vpc"
# }

output "vpc_name" {
  value = google_compute_network.vpc_network.name
}

output "main_subnet_name" {
  value = google_compute_subnetwork.main_subnet.name
}
""",

        "iam": """# Cuenta de servicio
resource "google_service_account" "service_account" {
  account_id   = "${var.project_id}-sa"
  display_name = "Cuenta de servicio para ${var.project_id}"
  description  = "Cuenta de servicio creada por Terraform"
}

# Asignación de roles a nivel de proyecto
resource "google_project_iam_member" "project_roles" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/storage.objectViewer",
  ])
  
  project = var.project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.service_account.email}"
}

# Roles custom (opcional)
resource "google_project_iam_custom_role" "custom_role" {
  role_id     = "customRole${title(var.project_id)}"
  title       = "Custom Role for ${var.project_id}"
  description = "Rol personalizado con permisos específicos"
  permissions = [
    "storage.buckets.get",
    "storage.objects.list",
    "compute.instances.list",
  ]
}

# Binding para el rol custom
resource "google_project_iam_binding" "custom_role_binding" {
  project = var.project_id
  role    = google_project_iam_custom_role.custom_role.id
  
  members = [
    "serviceAccount:${google_service_account.service_account.email}",
  ]
}

# Clave para la cuenta de servicio (opcional, mejor usar Workload Identity)
# resource "google_service_account_key" "sa_key" {
#   service_account_id = google_service_account.service_account.name
#   public_key_type    = "TYPE_X509_PEM_FILE"
# }

output "service_account_email" {
  value = google_service_account.service_account.email
}
""",

        "firewall": """####################################
         FIREWALL RULES
####################################
# Allow SSH access on port 22
resource "google_compute_firewall" "allow_ssh" {
  name    = "${var.project_id}-allow-ssh"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["ssh-server"]
}

####################################
         HTTPS ACCESS
####################################
# Allow HTTPS access on port 443
resource "google_compute_firewall" "allow_https" {
  name    = "${var.project_id}-allow-https"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["https-server"]
}

####################################
         INTERNAL TRAFFIC
####################################
# Allow internal traffic within the network
resource "google_compute_firewall" "allow_internal" {
  name    = "${var.project_id}-allow-internal"
  network = "default"

  allow {
    protocol = "icmp"
  }

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  source_ranges = ["10.0.0.0/8"]
}

####################################
         BLOCK TRAFFIC
####################################
# Block specific traffic
resource "google_compute_firewall" "deny_specific" {
  name    = "${var.project_id}-deny-specific"
  network = "default"

  deny {
    protocol = "tcp"
    ports    = ["135", "137-139", "445"]
  }

  source_ranges = ["0.0.0.0/0"]
  priority      = 1000
}
""",

        "dns": """####################################
         DNS MANAGED ZONE
####################################
# Zona gestionada de Cloud DNS
resource "google_dns_managed_zone" "dns_zone" {
  name        = "${var.project_id}-zone"
  dns_name    = "example.${var.project_id}.com."
  description = "Zona DNS para ${var.project_id}"
  
  # Para zonas privadas
  # visibility = "private"
  # 
  # private_visibility_config {
  #   networks {
  #     network_url = google_compute_network.vpc_network.id
  #   }
  # }
}

####################################
         DNS RECORD SETS
####################################
# Registro A para el dominio principal
resource "google_dns_record_set" "a_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "A"
  ttl          = 300
  
  # IPs del balanceador de carga o VMs
  rrdatas = ["203.0.113.1"]
}

# Registro CNAME para subdominio
resource "google_dns_record_set" "cname_record" {
  name         = "www.example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "CNAME"
  ttl          = 300
  rrdatas      = ["example.${var.project_id}.com."]
}

# Registro MX para correo
resource "google_dns_record_set" "mx_record" {
  name         = "example.${var.project_id}.com."
  managed_zone = google_dns_managed_zone.dns_zone.name
  type         = "MX"
  ttl          = 3600
  rrdatas      = ["10 mail.example.${var.project_id}.com."]
}

# Política de DNS (opcional)
resource "google_dns_policy" "dns_policy" {
  name                      = "${var.project_id}-dns-policy"
  description               = "Política DNS para ${var.project_id}"
  enable_inbound_forwarding = true
  
  networks {
    network_url = "projects/${var.project_id}/global/networks/default"
  }
}

output "dns_zone_name" {
  value = google_dns_managed_zone.dns_zone.name
}

output "dns_name_servers" {
  value = google_dns_managed_zone.dns_zone.name_servers
}
""",

        "cloud-armor": """####################################
         CLOUD ARMOR POLICY
####################################
# Política de seguridad de Cloud Armor
resource "google_compute_security_policy" "policy" {
  name        = "${var.project_id}-security-policy"
  description = "Política de Cloud Armor para ${var.project_id}"
  
  # Regla por defecto (denegar todo lo que no esté permitido explícitamente)
  rule {
    action   = "deny(403)"
    priority = "2147483647"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["*"]
      }
    }
    description = "Regla por defecto"
  }
  
  # Regla para permitir IPs específicas
  rule {
    action   = "allow"
    priority = "1000"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Permitir rango de IPs específico"
  }
  
  # Regla para bloquear IPs por geolocalización
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      expr {
        expression = "origin.region_code == 'CN'"
      }
    }
    description = "Bloquear tráfico por geolocalización"
  }
  
  # Regla para bloquear IPs específicas
  rule {
    action   = "deny(403)"
    priority = "1001"
    match {
      versioned_expr = "SRC_IPS_V1"
      config {
        src_ip_ranges = ["192.0.2.0/24"]
      }
    }
    description = "Bloquear rango de IPs específico"
  }
  
  # Regla para proteger contra XSS
  rule {
    action   = "deny(403)"
    priority = "1002"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('xss-stable')"
      }
    }
    description = "Proteger contra XSS"
  }
  
  # Regla para proteger contra SQL injection
  rule {
    action   = "deny(403)"
    priority = "1003"
    match {
      expr {
        expression = "evaluatePreconfiguredExpr('sqli-stable')"
      }
    }
    description = "Proteger contra SQL injection"
  }

  # Regla para limitar la tasa por IP
  # adaptive_protection_config {
  #   layer_7_ddos_defense_config {
  #     enable = true
  #   }
  # }
}

output "security_policy_id" {
  value = google_compute_security_policy.policy.id
}
""",

        "cdn": """####################################
         CDN BUCKET
####################################
resource "google_storage_bucket" "cdn_bucket" {
  name          = "${var.project_id}-cdn-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
  
  # Habilitar versionado (opcional)
  versioning {
    enabled = true
  }
}

####################################
         CDN BACKEND
####################################
resource "google_compute_backend_bucket" "cdn_backend" {
  name        = "${var.project_id}-cdn-backend"
  description = "Backend para CDN de ${var.project_id}"
  bucket_name = google_storage_bucket.cdn_bucket.name
  enable_cdn  = true
  
  cdn_policy {
    cache_mode        = "CACHE_ALL_STATIC"
    client_ttl        = 3600
    default_ttl       = 3600
    max_ttl           = 86400
    negative_caching  = true
    serve_while_stale = 86400
  }
}

####################################
         CDN URL MAP
####################################
resource "google_compute_url_map" "cdn_url_map" {
  name            = "${var.project_id}-cdn-url-map"
  description     = "URL map para CDN de ${var.project_id}"
  default_service = google_compute_backend_bucket.cdn_backend.id
  
  host_rule {
    hosts        = ["cdn.example.${var.project_id}.com"]
    path_matcher = "cdn-path-matcher"
  }
  
  path_matcher {
    name            = "cdn-path-matcher"
    default_service = google_compute_backend_bucket.cdn_backend.id
    
    path_rule {
      paths   = ["/images/*"]
      service = google_compute_backend_bucket.cdn_backend.id
    }
  }
}

####################################
         CDN HTTPS PROXY
####################################
resource "google_compute_target_https_proxy" "cdn_https_proxy" {
  name             = "${var.project_id}-cdn-https-proxy"
  url_map          = google_compute_url_map.cdn_url_map.id
  ssl_certificates = ["${var.project_id}-cert"]  # Debe existir o referencia a un certificado existente
}

####################################
         CDN IP ADDRESS
####################################
resource "google_compute_global_address" "cdn_ip" {
  name        = "${var.project_id}-cdn-ip"
  description = "Dirección IP para CDN de ${var.project_id}"
}

####################################
         CDN HTTPS FORWARDING RULE
####################################
resource "google_compute_global_forwarding_rule" "cdn_https_forwarding_rule" {
  name                  = "${var.project_id}-cdn-https-rule"
  target                = google_compute_target_https_proxy.cdn_https_proxy.id
  port_range            = "443"
  ip_address            = google_compute_global_address.cdn_ip.address
  load_balancing_scheme = "EXTERNAL"
}

output "cdn_ip" {
  value = google_compute_global_address.cdn_ip.address
}

output "cdn_bucket" {
  value = google_storage_bucket.cdn_bucket.name
}
""",

        "cloud-nat": """####################################
         CLOUD NAT ROUTER
####################################
resource "google_compute_router" "router" {
  name    = "${var.project_id}-nat-router"
  region  = var.region
  network = google_compute_network.vpc_network.id

  bgp {
    asn = 64514
  }
}

####################################
         CLOUD NAT CONFIG
####################################
resource "google_compute_router_nat" "nat" {
  name                               = "${var.project_id}-nat-config"
  router                             = google_compute_router.router.name
  region                             = var.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}

output "nat_router_name" {
  value = google_compute_router.router.name
}
""",

        "ssl-certificate": """####################################
         SSL CERTIFICATE MANAGED
####################################
# Certificado SSL gestionado por Google
resource "google_compute_managed_ssl_certificate" "managed" {
  name = "${var.project_id}-managed-cert"

  managed {
    domains = ["example.${var.project_id}.com", "www.example.${var.project_id}.com"]
  }
}

####################################
         SSL CERTIFICATE SELF SIGNED
####################################
# Certificado autofirmado (para desarrollo/pruebas)
resource "google_compute_ssl_certificate" "self_signed" {
  name        = "${var.project_id}-self-signed-cert"
  description = "Certificado autofirmado para ${var.project_id} (desarrollo)"
  
  # En un escenario real, estos vendrían de variables o archivos seguros
  private_key = file("path/to/private.key")
  certificate = file("path/to/certificate.crt")
  
  lifecycle {
    create_before_destroy = true
  }
}

output "managed_cert_id" {
  value = google_compute_managed_ssl_certificate.managed.id
}

output "managed_cert_name" {
  value = google_compute_managed_ssl_certificate.managed.name
}
"""
    },
}


def listar_servicios():
    """
    Devuelve la información de todos los servicios disponibles.
    
    Returns:
        dict: Información detallada de los servicios
    """
    return SERVICIOS_INFO


def obtener_servicio_template(servicio: str) -> str:
    """
    Obtiene el contenido de la plantilla para un servicio específico.
    
    Args:
        servicio: Nombre del servicio
    
    Returns:
        str: Contenido de la plantilla Terraform
    """
    if servicio not in SERVICIOS_DISPONIBLES:
        raise ValueError(f"Servicio '{servicio}' no reconocido")
    
    # Plantillas predefinidas para cada servicio
    templates = {
        "compute-engine": """/*===========================================================
                      COMPUTE ENGINE VM
===========================================================*/
resource "google_compute_instance" "vm_instance" {
  name         = "${var.project_id}-vm"
  machine_type = "e2-medium"
  zone         = var.zone

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  network_interface {
    network = "default"
    access_config {
      # Asigna IP pública
    }
  }

  metadata_startup_script = "echo 'Hola desde la VM' > /var/www/html/index.html"

  tags = ["http-server", "https-server"]
}

/*===========================================================
                      FIREWALL RULES
===========================================================*/
resource "google_compute_firewall" "allow_http" {
  name    = "${var.project_id}-allow-http"
  network = "default"

  allow {
    protocol = "tcp"
    ports    = ["80"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["http-server"]
}
""",

        "cloud-storage": """/*===========================================================
                      CLOUD STORAGE
===========================================================*/
resource "google_storage_bucket" "bucket" {
  name          = "${var.project_id}-bucket"
  location      = var.region
  force_destroy = true
  
  uniform_bucket_level_access = true
  
  website {
    main_page_suffix = "index.html"
    not_found_page   = "404.html"
  }
  
  cors {
    origin          = ["*"]
    method          = ["GET", "HEAD", "PUT", "POST", "DELETE"]
    response_header = ["*"]
    max_age_seconds = 3600
  }
}

/*===========================================================
                      BUCKET IAM
===========================================================*/
resource "google_storage_bucket_iam_member" "public_rule" {
  bucket = google_storage_bucket.bucket.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}

output "bucket_url" {
  value = "gs://${google_storage_bucket.bucket.name}"
}

output "bucket_website_url" {
  value = "https://storage.googleapis.com/${google_storage_bucket.bucket.name}/index.html"
}
""",

        "cloud-sql": """# Instancia de Cloud SQL
resource "google_sql_database_instance" "instance" {
  name             = "${var.project_id}-db-instance"
  database_version = "MYSQL_8_0"
  region           = var.region
  
  settings {
    tier = "db-f1-micro"
    
    backup_configuration {
      enabled            = true
      binary_log_enabled = true
      start_time         = "23:00"
    }
    
    ip_configuration {
      ipv4_enabled    = true
      require_ssl     = false
      private_network = null
    }
  }
  
  deletion_protection = false  # Para entornos de desarrollo
}

# Base de datos
resource "google_sql_database" "database" {
""",}
    
    return templates[servicio] 